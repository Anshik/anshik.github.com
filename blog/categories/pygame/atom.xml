<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pygame | Ещё один блог]]></title>
  <link href="http://Anshik.github.com/blog/categories/pygame/atom.xml" rel="self"/>
  <link href="http://Anshik.github.com/"/>
  <updated>2013-11-27T15:25:38+04:00</updated>
  <id>http://Anshik.github.com/</id>
  <author>
    <name><![CDATA[Anshik]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pygame инициализация, работа с прямоугольниками, прозрачностью]]></title>
    <link href="http://Anshik.github.com/blog/2013/10/22/pygame-initsializatsiia/"/>
    <updated>2013-10-22T13:38:00+04:00</updated>
    <id>http://Anshik.github.com/blog/2013/10/22/pygame-initsializatsiia</id>
    <content type="html"><![CDATA[<h2>Инициализация</h2>

<p>Для работы с pygame следует инициализировать необходимые модули, проще всего инициализировать все:
<code>pygame.init()</code><br/>
Существует несколько вариантов инициализации окна pygame:</p>

<!-- more -->


<h2>Создание рабочей области окна</h2>

<h3>Создание окна требуемого размера.</h3>

<p><code>python
screen = pygame.display.set_mode((320, 240))
</code></p>

<h3>Создание окна исходя из размеров фона</h3>

<p><code>python
background = pygame.image.load('media/img_backgournd.jpg')
screen = pygame.display.set_mode(background.get_size())
screen.blit(background, (0, 0))
</code></p>

<h2>Работа с прямоугольниками и текстом</h2>

<p>Прямоугольники служат для выбора части поверхностей, для получения размеров областей и др.
Конструктор простейшего прямоугольника выглядит так:
``` python
In [1]: import pygame</p>

<p>In [2]: r = pygame.Rect(0, 0, 100, 50)   # 100х50 px</p>

<p>In [3]: r
Out[3]: &lt;rect(0, 0, 100, 50)>
```
У объекта класса Rect есть множество методов, названия говорят за себя:<br/>
['bottom', 'bottomleft', 'bottomright', 'center', 'centerx', 'centery', 'clamp', 'clamp_ip', 'clip', 'collidedict', 'collidedictall',
 'collidelist', 'collidelistall', 'collidepoint', 'colliderect', 'contains', 'copy', 'fit', 'h', 'height', 'inflate', 'inflate_ip',
 'left', 'midbottom', 'midleft', 'midright', 'midtop', 'move', 'move_ip', 'normalize', 'right', 'size', 'top', 'topleft',
 'topright', 'union', 'union_ip', 'unionall', 'unionall_ip', 'w', 'width', 'x', 'y']</p>

<p>Из этих атрибутов я выделю centerx и centery:
``` python
font = pygame.font.Font('media/presentum.ttf', 30)      # задание шрифта и размера
text_img = font.render('Строка для рендеринга', True, 0xFF0000) # строка, сглаживание, цвет</p>

<p>text_pos = text_img.get_rect()      # получаем пр-к нашего текста
text_pos.centerx = r.centerx        # центрируем позицию нашего текста по середине контейнера r
text_pos.centery = r.centery        # центрируем позицию нашего текста по середине контейнера r</p>

<p>screen.blit(text_img, text_pos)     # копирование текста на экран
pygame.display.update()             # обновление экрана
```</p>

<h2>Прозрачность (Альфа-канал)</h2>

<p>Для загрузки изображения из png файла с альфа каналом следует использовать следующую строчку:</p>

<p><code>pic_with_alpha = pygame.image.load('media/src_with_alpha.png').convert_alpha()</code></p>

<p>Для получения изображения с прозрачным фоном мы редактируем png, удаляем фон, затем сохраняем файл без сохранения цвета прозрачности.</p>

<h3>Создание прозрачности для сложных поверхностей, полигонов и прочего</h3>

<p>Моё решение было следующим:<br/>
Немного меняю исходное изображение для того чтобы чёрный цвет не превратился в прозрачный, затем накладываю чёрную маску на изображение, говорю, что чёрный цвет становится прозрачным.</p>

<p>``` python</p>

<h1>Берём изображение, подгоняем под размер</h1>

<p>img = pygame.image.load('media/src.png')
img_s = pygame.transform.scale(img, (204, 142))</p>

<h1>нужно заместить черный в исходном изображении на +1, иначе станет прозрачным</h1>

<p>pa_img_s = pygame.PixelArray(img_s)         # создаем массив для замены цвета
pa_img_s.replace((0, 0, 0), (0, 0, 1))      # заменяем цвет
img_s = pa_img_s.surface
del pa_img_s                                # удаляем, иначе блочит поверхность</p>

<p>s = pygame.Surface((240, 146))              # поверхность для преобразований
pat = pygame.image.load('media/pattern.png').convert_alpha()        # накладываем чёрный шаблон, с прозрачными вырезами</p>

<p>s.blit(img_s, (0, 0))   # копируем наше изображение с "немного не чёрным цветом" на поверхность для преобразований
s.blit(pat, (0, 0))     # сверху накладываем (копируем) маску
s.set_colorkey(pygame.Color('black'))       # устанавливаем чёрный цвет прозрачным
```</p>

<h2>Выделение части поверхности</h2>

<p>Мой стандартный use-case использования части поверхности (subsurface) &mdash; это копирование части фона для создания эффектов движения, анимации:</p>

<ul>
<li>копируем часть фона, на котором будет происходить действие</li>
<li>копируем изменение</li>
<li>ждем</li>
<li>снова копируем фон.</li>
</ul>


<p>``` python</p>

<h1>задаём фон</h1>

<p>background = pygame.image.load('media/img_backgournd.jpg')
screen = pygame.display.set_mode(background.get_size())
screen.blit(background, (0, 0))</p>

<p>r = pygame.Rect(0, 0, 300, 400)     # размеры пр-ка, на котором будет производиться действие
ball = pygame.image.load('media/ball.png')  # загружаем картинку
bg = background.subsurface(r)               # создаём копию фона
x_pos_left = 0
y_pos = 0
c = 10
while c:</p>

<pre><code>x_pos_left += 10
screen.blit(bg, (0, 0))       # копируем фон
screen.blit(ball, (x_pos_left, y_pos))   # копируем картинку поверх
c -= 1
pygame.display.update(r)    # обновлять не обязательно весь экран, можно определённую часть.
sleep(0.08)                 # задержка, можно использовать pygame-овскую
</code></pre>

<p>```</p>

<h2>Работа с событиями (events)</h2>

<p>Данный вопрос рассмотрен везде, но не упомянуть его нельзя :)</p>

<p>``` python простейший выход из приложения по кнопке</p>

<pre><code>bRunning = True

while bRunning:

    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                bRunning = False
                exit(0) # к примеру
</code></pre>

<p>```</p>

<p>А это пример кастомного события</p>

<p>``` python</p>

<h1>coding=utf-8</h1>

<p>import pygame</p>

<p>COUNTER = pygame.USEREVENT + 5  # 24+5 = 29</p>

<p>class Counter():</p>

<pre><code>def __init__(self, coord, screen, background, counter, up):
    self.current_sub_timer = 0
    self.coord = coord
    self.screen = screen
    self.counter = counter      # сколько секунд считать
    self.up = up                # если 1, возрастает счётчик, 0, убывает

    rendtext = self.get_colored_text(str(30), (255, 0, 0))
    r = rendtext.get_rect()         # взяли 30 и увеличили размер пр-ка

    self.bg = background.subsurface(r.move(self.coord))     # сдвинули пр-к и взяли фон

def get_colored_text(self, text, color):
    bigfont = pygame.font.Font('presentum.ttf', 60)
    rendtext = bigfont.render(text, True, color)
    return rendtext

def get_next(self):
    """
    возвращет 0 если таймер оттикал
    """
    cur_second = self.current_sub_timer / 10
    if self.current_sub_timer / 10 == self.counter:
        return 0
    else:
        if self.up:
            new_val = cur_second + 1
        else:
            new_val = self.counter - cur_second
        rendtext = self.get_colored_text(str(new_val), (255, 0, 0))
        self.screen.blit(self.bg, self.coord)
        self.screen.blit(rendtext, self.coord)
        pygame.display.update()
        self.current_sub_timer += 1
        return 1
</code></pre>

<p>def main():</p>

<pre><code>pygame.init()
screen = pygame.display.set_mode((1024, 768))
background = pygame.image.load('media/screen3.jpg')
screen.blit(background,(0, 0))
pygame.display.update()

pygame.time.set_timer(COUNTER, 100)     # запускаем генерацию even-тов каждые 100мс
counter = Counter((350, 300), screen, background, 5, 0) # передаём где вывести счётчик, 
                                                        # наш экран, фон, сколько секунд считать, 0 - убывает

b_running = True
while b_running:

    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                b_running = False

        elif event.type == COUNTER:

            if not counter.get_next():
                pygame.time.set_timer(COUNTER, 0)   # значит оттикал таймер, нужно остановить генерацию событий
</code></pre>

<p>if <strong>name</strong> == '<strong>main</strong>':</p>

<pre><code>main()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
